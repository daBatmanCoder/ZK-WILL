# zk-will


The project is based on the source code of [Tornado Cash](https://github.com/tornadocash/tornado-core). The most essential component of tornado core is a Merkle tree where users can deposit ethers with a random `commitment`, that can be withdrawn with a `nullifier`. The nullifier is assigned to the commitment, but nobody knows which commitment is assigned to which nullifier, because the link between them is the zero-knowledge.

## Set up

We need to install the following libraries for this project-
- node modules - `circomlib`,
                 `snarkjs` 

- circom - ("https://docs.circom.io/getting-started/installation/")



## Usage

First we start with our circuits

### Merkle Tree

- We generate a file named - merkleTree.circom (taken complelty from tornado cash)

```java
pragma circom 2.0.0;

include "../node_modules/circomlib/circuits/mimcsponge.circom";

// Computes MiMC([left, right])
template HashLeftRight() {
    signal input left;
    signal input right;
    signal output hash;

    component hasher = MiMCSponge(2, 220, 1);
    hasher.ins[0] <== left;
    hasher.ins[1] <== right;
    hasher.k <== 0;
    hash <== hasher.outs[0];
}

// if s == 0 returns [in[0], in[1]]
// if s == 1 returns [in[1], in[0]]
template DualMux() {
    signal input in[2];
    signal input s;
    signal output out[2];

    s * (1 - s) === 0;
    out[0] <== (in[1] - in[0])*s + in[0];
    out[1] <== (in[0] - in[1])*s + in[1];
}

// Verifies that merkle proof is correct for given merkle root and a leaf
// pathIndices input is an array of 0/1 selectors telling whether given pathElement is on the left or right side of merkle path
template MerkleTreeChecker(levels) {
    signal input leaf;
    signal input pathElements[levels];
    signal input pathIndices[levels];
    signal output root;

    component selectors[levels];
    component hashers[levels];

    for (var i = 0; i < levels; i++) {
        selectors[i] = DualMux();
        selectors[i].in[0] <== i == 0 ? leaf : hashers[i - 1].hash;
        selectors[i].in[1] <== pathElements[i];
        selectors[i].s <== pathIndices[i];

        hashers[i] = HashLeftRight();
        hashers[i].left <== selectors[i].out[0];
        hashers[i].right <== selectors[i].out[1];
    }

    root <== hashers[levels - 1].hash;
}


```

This Circom code defines two templates (HashLeftRight and DualMux) and one main template (MerkleTreeChecker) to verify the correctness of a Merkle proof for a given leaf in a Merkle tree with a specified number of levels.

- HashLeftRight Template
This template computes a hash using the MiMC sponge construction (MiMCSponge from circomlib) for two inputs: left and right. It initializes the MiMCSponge component with 2 inputs, a capacity of 220, and 1 output. The template sets the inputs of the hasher component to the left and right signals and fixes the key k to 0, following the MiMC specification. The output, hash, is set to the first output of the hasher.

- DualMux Template
This template implements a multiplexer that swaps its two inputs (in[0] and in[1]) based on a selector signal s. If s is 0, the outputs out[0] and out[1] are equal to in[0] and in[1], respectively. If s is 1, the outputs are swapped. The template includes a constraint to ensure s is either 0 or 1.

- MerkleTreeChecker Template
This template verifies a Merkle proof by iteratively hashing up the Merkle tree from a given leaf to the root. It uses the leaf signal as the starting point and pathElements as the complementary elements along the path to the root. pathIndices determine the position (left or right) of each pathElement in the path.


For each level of the tree, the template uses a DualMux component to select the correct order of elements based on pathIndices and then hashes the selected pair using a HashLeftRight component. The process is repeated for each level of the tree, with the output of each hash serving as the input to the next level. The final hash at the top level is considered the computed root of the Merkle tree, which should match the actual root for the proof to be valid.
(Usually being done in the blockchain)


## Now that we understood how merkle tree circuit is working we can continue to the withdraw implementation

### Withdraw (Will)

- Create another file named- `withdraw.circom` with the following


```java
pragma circom 2.0.0;

include "../node_modules/circomlib/circuits/bitify.circom";
include "../node_modules/circomlib/circuits/mimcsponge.circom";
include "merkleTree.circom";


template CommitmentHasher() {
    signal input nullifier;
    signal input secret;
    signal output commitment;
    signal output nullifierHash;

    component commitmentHasher = MiMCSponge(2, 220, 1);
    component nullifierHasher = MiMCSponge(1, 220, 1);

    commitmentHasher.ins[0] <== nullifier;
    commitmentHasher.ins[1] <== secret;
    commitmentHasher.k <== 0;

    nullifierHasher.ins[0] <== nullifier;
    nullifierHasher.k <== 0;

    commitment <== commitmentHasher.outs[0];
    nullifierHash <== nullifierHasher.outs[0];
}


template withdraw(levels) {
    signal input nullifier;
    signal input secret;
    signal input pathElements[levels];
    signal input pathIndices[levels];
    signal output nullifierHash;
    signal output root;

    component commitmentHasher = CommitmentHasher();
    component merkleTreeChecker = MerkleTreeChecker(levels);

    commitmentHasher.nullifier <== nullifier;
    commitmentHasher.secret <== secret;

    merkleTreeChecker.leaf <== commitmentHasher.commitment;
    for (var i = 0; i < levels; i++) {
        merkleTreeChecker.pathElements[i] <== pathElements[i];
        merkleTreeChecker.pathIndices[i] <== pathIndices[i];
    }

    nullifierHash <== commitmentHasher.nullifierHash;
    root <== merkleTreeChecker.root;
}

component main = Verifier(20);

```


This Circom code snippet defines two templates (CommitmentHasher and withdraw) for generating a commitment from a nullifier and secret, and verifying a Merkle proof for a withdrawal operation in a privacy-preserving protocol like a mixer or a confidential transaction system.

- CommitmentHasher Template
    This template is responsible for generating two cryptographic hashes: a commitment and a nullifierHash. It takes two inputs: nullifier and secret, which are used to generate a unique commitment using the MiMCSponge hash function. The commitmentHasher component hashes both nullifier and secret together, while the nullifierHasher component hashes only the nullifier. The output of these hashing operations are the commitment and nullifierHash, respectively.

- Withdraw Template
    This template represents the circuit for a withdrawal operation, requiring a nullifier, a secret, a series of path elements (pathElements), and their corresponding positions (pathIndices) in the Merkle tree as inputs. It uses the CommitmentHasher to hash the nullifier and secret to generate a commitment and a nullifierHash.

The commitment is then used as a leaf in the MerkleTreeChecker template to verify the correctness of the Merkle proof provided through pathElements and pathIndices. The MerkleTreeChecker outputs the root of the Merkle tree, which can be compared against a known root to verify the proof's validity.

The withdraw template thus encapsulates the entire process of verifying a withdrawal operation in a system where transactions are hidden for privacy but need to be verifiable for security. This is achieved by verifying that the commitment made during the deposit phase is part of the Merkle tree and that the nullifier has not been used before, preventing double-spending.

The component main is the entry point of the circuit.


## Circuit compiling
Now we need to call the following commands in order to compile the circuit-
you can also follow the steps in the circom website("https://docs.circom.io/getting-started/installation/")

```bash
circom verifier.circom --r1cs --wasm --sym --c
```
```bash
snarkjs powersoftau new bn128 15 pot15_0000.ptau -v
```
- We needed to use pot15 because the number of constrains

```bash
snarkjs powersoftau contribute pot15_0000.ptau pot15_0001.ptau --name="First contribution" -v
```
```bash
snarkjs powersoftau prepare phase2 pot15_0001.ptau pot15_final.ptau -v
```
```bash
snarkjs groth16 setup verifier.r1cs pot15_final.ptau verifier_0000.zkey
```
```bash
snarkjs zkey contribute verifier_0000.zkey verifier_0001.zkey --name="1st Contributor Name" -v
```
```bash
snarkjs zkey export verificationkey verifier_0001.zkey verification_key.json
```

### Smart contract creation 

```bash
snarkjs zkey export solidityverifier verifier_0001.zkey verifier.sol
```

This command is used to generate a Solidity smart contract that can verify a zk-SNARK proof- pay attention that every time you compile the verifier.sol will be different,
in the steps you did that compiled the circuit you entered different entropy to the ceremony.


###

Now let's go over the contracts-

#### ZKWillHandler is the co-pilot for the ZK-Will contract that implemented the logic

```solidity
// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.20;

import "./MerkleTreeWithHistory.sol";

interface IVerifier {

    function verifyProof(
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint[2] memory input
    ) external pure returns (bool r);

}

contract ZKWillHandler is MerkleTreeWithHistory {

    mapping(bytes32 => bool) public nullifiers;
    mapping(bytes32 => bool) public commitments;
    mapping(address => uint256) public TTL;

    IVerifier public immutable verifier;

    event Commit(
        bytes32 indexed commitment,
        uint32 leafIndex,
        uint256 timestamp
    );

    event TimeStep(
        uint256 previous_timestep,
        uint256 timestap
    );

    constructor(
        uint32 _levels,
        IHasher _hasher,
        IVerifier _verifier
    ) MerkleTreeWithHistory(_levels, _hasher) {
        verifier = _verifier;
    }

    function _depositWill(bytes32 _commitmentDeposit) internal {
        require(!commitments[_commitmentDeposit], "The commitment has been submitted");

        commitments[_commitmentDeposit] = true;

        TTL[msg.sender] = block.timestamp;

        uint32 insertedIndex = _insert(_commitmentDeposit);
        emit Commit(_commitmentDeposit, insertedIndex, block.number);
    }

    function _withdrawWill(
        uint[2] memory _proof_a,
        uint[2][2] memory _proof_b,
        uint[2] memory _proof_c,
        bytes32 _nullifierHash,
        bytes32 _root
    ) internal view returns (string memory){
        require(!nullifiers[_nullifierHash], "The nullifier has been submitted");
        require(isKnownRoot(_root), "Cannot find your merkle root");
        require(
            verifier.verifyProof(
                _proof_a,
                _proof_b,
                _proof_c,
                [uint256(_nullifierHash), uint256(_root)]
            ),
            "Invalid proof"
        );

        uint secondsElapsed = (block.timestamp - TTL[msg.sender]) * 2;
        string memory secondsPast = uintToString(secondsElapsed);
        return string(abi.encodePacked(secondsPast, " seconds past from the deposit"));
    }

    function uintToString(uint v) internal pure returns (string memory) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = bytes1(uint8(48 + remainder));
        }
        bytes memory s = new bytes(i);
        for (uint j = 0; j < i; j++) {
            s[j] = reversed[i - 1 - j];
        }

        return string(s);
    }

}
```

The constructor has 3 parameters:
- `_levels` is the levels of the Merkle tree. **It has to be 20 if you use the default Verifier.** If you want to use different number of levels, you have to implement your own Verifier circuit.
- `_hasher` is the address of the MiMC sponge smart contract. * in order to generate this contract you'll have to use hardhat and circomlibjs library. - (more about it in the future, for now if you're in Mumbai(polygon testnet) you can use this address - 0xfCb643f284A5dC8ae58Ce8670e56E18918702984 )
- `_verifier` is the address of the Verifier contract. It is generated from the Verifier (`circuits/Verifier.circom`) circuit by the prepare script (`scripts/preapre.sh`).


The `_depositWill` method implements the `depositWill` method. It has 1 parameters:
- `_commitment` is the commitment of the user.

The `_withdrawWill` method implements the `withdrawWill` method. It has 5 parameters:
- `_nullifierHash` is the nullifier hash for the commitment.
- `_root` is the Merkle root for the proof.
- `_proof_a`, `_proof_b` and `_proof_c` are the zero-knowledge proof.
(for now this function returns the Time paste since the deposit- no state changer)

The commitment and the nullifier hash are generated on the client side by the `generateCommitment` method in the `generateCommit.js` file(later specific implementation)

To generate the zero-knowledge proof, use `prepareProofFile` in the `generateProof` file,
(aswell specific later)

#### ZKWill 

this contract is the direct interaction with the 2 methods-

```solidity
// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.20;

import "./ZKWillHandler.sol";

contract ZKWill is ZKWillHandler {

    constructor(
        uint32 _levels,
        IHasher _hasher,
        IVerifier _verifier
    ) ZKWillHandler(_levels, _hasher, _verifier) {}

    function commitDeposit(uint256 _commitmentDeposit) external {
        _depositWill(bytes32(_commitmentDeposit));
    }

    function withdrawWill(
        uint[2] memory _proof_a,
        uint[2][2] memory _proof_b,
        uint[2] memory _proof_c,
        uint256 _nullifierHash,
        uint256 _root
    ) external view returns (string memory){
         return _withdrawWill(
            _proof_a,
            _proof_b,
            _proof_c,
            bytes32(_nullifierHash),
            bytes32(_root)
        );
    }
}
```

The `commitDeposit` is the `_depositWill` co-pilot,
The `withdrawWill` is the `_withdrawWill` co-pilot aswell.

#### MerkleTreeWithHistory is exactly the same as tornado cash

## How to start
Our whole interaction with the blockchain is going to be with the ZK-Will contract.
We can start commiting wills and withdrawing when desired.

### generateCommit.js

First we need to generate the `nullifier` and the `secret`, hash them together using MiMCSponge hashing algo' (the choice for that algo' is because it's fast with zk-proofs, reliable and cheap), output the `commitment`, and call the method - `commitDeposit` from the deployed contract.

That will input the tree the newly created commitment.

### generateProof.js

Whenever we want to withdraw the will(for now it's just going to return the time past since the deposit of the will), we need to look at the current state of the tree with our nullifier and secret, and calculate the path and indicies to the state the tree is in.
To achieve that we call the `prepareProofFile` function, that will read the nullifier and the secret from a local file- `null_n_secret.json`, and will calculate the the input file necessary to perfrom the proof- and will write to `input.json` already in the witness relevant folder, for me it was- `./circuits/verifier_js/`,
now that we have generate the relevant input for the circuit to calculate the proof, we can call- 
```bash

```






WARNING: This library is not audited, so use it at your own risk.