# zk-will


The project is based on the source code of [Tornado Cash](https://github.com/tornadocash/tornado-core). The most essential component of tornado core is a Merkle tree where users can deposit ethers with a random `commitment`, that can be withdrawn with a `nullifier`. The nullifier is assigned to the commitment, but nobody knows which commitment is assigned to which nullifier, because the link between them is the zero-knowledge.

## Set up,

We need to install the following libraries for this project-
`circomlib` - for the circuits,


## Usage

First we start with our circuits,

### Merkle Tree

- We generate a file named - merkleTree.circom (taken complelty from tornado cash),

```java
pragma circom 2.0.0;

include "../node_modules/circomlib/circuits/mimcsponge.circom";

// Computes MiMC([left, right])
template HashLeftRight() {
    signal input left;
    signal input right;
    signal output hash;

    component hasher = MiMCSponge(2, 220, 1);
    hasher.ins[0] <== left;
    hasher.ins[1] <== right;
    hasher.k <== 0;
    hash <== hasher.outs[0];
}

// if s == 0 returns [in[0], in[1]]
// if s == 1 returns [in[1], in[0]]
template DualMux() {
    signal input in[2];
    signal input s;
    signal output out[2];

    s * (1 - s) === 0;
    out[0] <== (in[1] - in[0])*s + in[0];
    out[1] <== (in[0] - in[1])*s + in[1];
}

// Verifies that merkle proof is correct for given merkle root and a leaf
// pathIndices input is an array of 0/1 selectors telling whether given pathElement is on the left or right side of merkle path
template MerkleTreeChecker(levels) {
    signal input leaf;
    signal input pathElements[levels];
    signal input pathIndices[levels];
    signal output root;

    component selectors[levels];
    component hashers[levels];

    for (var i = 0; i < levels; i++) {
        selectors[i] = DualMux();
        selectors[i].in[0] <== i == 0 ? leaf : hashers[i - 1].hash;
        selectors[i].in[1] <== pathElements[i];
        selectors[i].s <== pathIndices[i];

        hashers[i] = HashLeftRight();
        hashers[i].left <== selectors[i].out[0];
        hashers[i].right <== selectors[i].out[1];
    }

    root <== hashers[levels - 1].hash;
}


```

This Circom code defines two templates (HashLeftRight and DualMux) and one main template (MerkleTreeChecker) to verify the correctness of a Merkle proof for a given leaf in a Merkle tree with a specified number of levels.

- HashLeftRight Template
This template computes a hash using the MiMC sponge construction (MiMCSponge from circomlib) for two inputs: left and right. It initializes the MiMCSponge component with 2 inputs, a capacity of 220, and 1 output. The template sets the inputs of the hasher component to the left and right signals and fixes the key k to 0, following the MiMC specification. The output, hash, is set to the first output of the hasher.

- DualMux Template
This template implements a multiplexer that swaps its two inputs (in[0] and in[1]) based on a selector signal s. If s is 0, the outputs out[0] and out[1] are equal to in[0] and in[1], respectively. If s is 1, the outputs are swapped. The template includes a constraint to ensure s is either 0 or 1.

- MerkleTreeChecker Template
This template verifies a Merkle proof by iteratively hashing up the Merkle tree from a given leaf to the root. It uses the leaf signal as the starting point and pathElements as the complementary elements along the path to the root. pathIndices determine the position (left or right) of each pathElement in the path.


For each level of the tree, the template uses a DualMux component to select the correct order of elements based on pathIndices and then hashes the selected pair using a HashLeftRight component. The process is repeated for each level of the tree, with the output of each hash serving as the input to the next level. The final hash at the top level is considered the computed root of the Merkle tree, which should match the actual root for the proof to be valid.
(Usually being done in the blockchain)

#####
Now that we understood how merkle tree circuit is working we can continue to the withdraw implementation

### Withdraw (Will)

- Create another file named- `withdraw.circom` with the following


```java
pragma circom 2.0.0;

include "../node_modules/circomlib/circuits/bitify.circom";
include "../node_modules/circomlib/circuits/mimcsponge.circom";
include "merkleTree.circom";


template CommitmentHasher() {
    signal input nullifier;
    signal input secret;
    signal output commitment;
    signal output nullifierHash;

    component commitmentHasher = MiMCSponge(2, 220, 1);
    component nullifierHasher = MiMCSponge(1, 220, 1);

    commitmentHasher.ins[0] <== nullifier;
    commitmentHasher.ins[1] <== secret;
    commitmentHasher.k <== 0;

    nullifierHasher.ins[0] <== nullifier;
    nullifierHasher.k <== 0;

    commitment <== commitmentHasher.outs[0];
    nullifierHash <== nullifierHasher.outs[0];
}


template withdraw(levels) {
    signal input nullifier;
    signal input secret;
    signal input pathElements[levels];
    signal input pathIndices[levels];
    signal output nullifierHash;
    signal output root;

    component commitmentHasher = CommitmentHasher();
    component merkleTreeChecker = MerkleTreeChecker(levels);

    commitmentHasher.nullifier <== nullifier;
    commitmentHasher.secret <== secret;

    merkleTreeChecker.leaf <== commitmentHasher.commitment;
    for (var i = 0; i < levels; i++) {
        merkleTreeChecker.pathElements[i] <== pathElements[i];
        merkleTreeChecker.pathIndices[i] <== pathIndices[i];
    }

    nullifierHash <== commitmentHasher.nullifierHash;
    root <== merkleTreeChecker.root;
}

component main = Verifier(20);

```


This Circom code snippet defines two templates (CommitmentHasher and withdraw) for generating a commitment from a nullifier and secret, and verifying a Merkle proof for a withdrawal operation in a privacy-preserving protocol like a mixer or a confidential transaction system.

- CommitmentHasher Template
    This template is responsible for generating two cryptographic hashes: a commitment and a nullifierHash. It takes two inputs: nullifier and secret, which are used to generate a unique commitment using the MiMCSponge hash function. The commitmentHasher component hashes both nullifier and secret together, while the nullifierHasher component hashes only the nullifier. The output of these hashing operations are the commitment and nullifierHash, respectively.

- Withdraw Template
    This template represents the circuit for a withdrawal operation, requiring a nullifier, a secret, a series of path elements (pathElements), and their corresponding positions (pathIndices) in the Merkle tree as inputs. It uses the CommitmentHasher to hash the nullifier and secret to generate a commitment and a nullifierHash.

The commitment is then used as a leaf in the MerkleTreeChecker template to verify the correctness of the Merkle proof provided through pathElements and pathIndices. The MerkleTreeChecker outputs the root of the Merkle tree, which can be compared against a known root to verify the proof's validity.

The withdraw template thus encapsulates the entire process of verifying a withdrawal operation in a system where transactions are hidden for privacy but need to be verifiable for security. This is achieved by verifying that the commitment made during the deposit phase is part of the Merkle tree and that the nullifier has not been used before, preventing double-spending.

The component main is the entry point of the circuit.


Now we need to call the following commands in order to compile the circuit-
```bash
circom verifier.circom --r1cs --wasm --sym --c
```

```bash
snarkjs powersoftau new bn128 15 pot15_0000.ptau -v
```
```bash
snarkjs powersoftau contribute pot15_0000.ptau pot15_0001.ptau --name="First contribution" -v
```
```bash
snarkjs powersoftau prepare phase2 pot15_0001.ptau pot15_final.ptau -v
```
```bash
snarkjs groth16 setup verifier.r1cs pot15_final.ptau verifier_0000.zkey
```
```bash
snarkjs zkey contribute verifier_0000.zkey verifier_0001.zkey --name="1st Contributor Name" -v
```
```bash
snarkjs zkey export verificationkey verifier_0001.zkey verification_key.json
```
































// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "zk-merkle-tree/contracts/ZKTree.sol";

contract ZKTreeVote is ZKTree {
    address public owner;
    mapping(address => bool) public validators;
    mapping(uint256 => bool) uniqueHashes;
    uint numOptions;
    mapping(uint => uint) optionCounter;

    constructor(
        uint32 _levels,
        IHasher _hasher,
        IVerifier _verifier,
        uint _numOptions
    ) ZKTree(_levels, _hasher, _verifier) {
        owner = msg.sender;
        numOptions = _numOptions;
        for (uint i = 0; i <= numOptions; i++) optionCounter[i] = 0;
    }

    function registerValidator(address _validator) external {
        require(msg.sender == owner, "Only owner can add validator!");
        validators[_validator] = true;
    }

    function registerCommitment(
        uint256 _uniqueHash,
        uint256 _commitment
    ) external {
        require(validators[msg.sender], "Only validator can commit!");
        require(
            !uniqueHashes[_uniqueHash],
            "This unique hash is already used!"
        );
        _commit(bytes32(_commitment));
        uniqueHashes[_uniqueHash] = true;
    }

    function vote(
        uint _option,
        uint256 _nullifier,
        uint256 _root,
        uint[2] memory _proof_a,
        uint[2][2] memory _proof_b,
        uint[2] memory _proof_c
    ) external {
        require(_option <= numOptions, "Invalid option!");
        _nullify(
            bytes32(_nullifier),
            bytes32(_root),
            _proof_a,
            _proof_b,
            _proof_c
        );
        optionCounter[_option] = optionCounter[_option] + 1;
    }

    function getOptionCounter(uint _option) external view returns (uint) {
        return optionCounter[_option];
    }
}
```

The constructor has 4 parameters:
- `_levels` is the levels of the Merkle tree. **It has to be 20 if you use the default Verifier.** If you want to use different number of levels, you have to implement your own Verifier circuit.
- `_hasher` is the address of the MiMC sponge smart contract. (Check the `test` folder for the MiMC sponge generator code.) 
- `_verifier` is the address of the Verifier contract. It is generated from the Verifier (`circuits/Verifier.circom`) circuit by the prepare script (`scripts/preapre.sh`).
- `_numOptions` is the number of options.


The `registerCommitment` method implements the `_commit` method. It has 2 parameters:
- `_uniqueHash` is a unique hash of the voter (ex.: the hash of the ID card). It ensures that one voter is registered only once.
- `_commitment` is the commitment of the user.

The `vote` method implements the `_nullify` method. It has 6 parameters:
- `_option` is the option what the voter chooses.
- `_nullifier` is the nullifier for the commitment.
- `_root` is the Merkle root for the proof.
- `_proof_a`, `_proof_b` and `_proof_c` are the zero-knowledge proof.

The commitment and the nullifier is generated on the client side by the `generateCommitment` method. (Please check the [VoterRegistration](https://github.com/TheBojda/zktree-vote/blob/main/src/components/VoterRegistration.vue) component in the `zktree-vote` project.) 

To generate the zero-knowledge proof, use `calculateMerkleRootAndZKProof`. (Please check the [Vote](https://github.com/TheBojda/zktree-vote/blob/main/src/components/Vote.vue) component in the `zktree-vote` project.)

For more info, please check the `test` folder in the repository and the [zktree-vote](https://github.com/TheBojda/zktree-vote) project.

WARNING: This library is not audited, so use it at your own risk.